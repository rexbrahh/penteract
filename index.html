<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Penteract → 3D with Shadows (Import-map fix)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- tiny transparent favicon to avoid 404 -->
    <link
      rel="icon"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E"
    >

    <!-- Import map to resolve bare specifiers -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <style>
      html, body {
        height: 100%;
        margin: 0;
        background: #0b0e13;
        color: #cbd5e1;
      }
      #app {
        position: fixed;
        inset: 0;
      }
      canvas {
        display: block;
      }
      .hint {
        position: fixed;
        left: 12px;
        bottom: 12px;
        font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        color: #9aa7b4;
        opacity: 0.9;
        background: rgba(0, 0, 0, 0.35);
        padding: 6px 8px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <div id="app"><canvas id="c"></canvas></div>
    <div class="hint">
      Drag = orbit • Wheel = zoom • Auto-rotating 5D planes
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      /* ------------------ Renderer / Scene / Camera ------------------ */
      const canvas = document.getElementById("c");
      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
      });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0e13);

      const camera = new THREE.PerspectiveCamera(
        55,
        innerWidth / innerHeight,
        0.1,
        100,
      );
      camera.position.set(4.2, 2.7, 5.6);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      /* -------------------------- Lights ----------------------------- */
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));

      const sun = new THREE.DirectionalLight(0xffffff, 1.15);
      sun.position.set(6, 8, 4);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.near = 1;
      sun.shadow.camera.far = 30;
      sun.shadow.camera.left = -10;
      sun.shadow.camera.right = 10;
      sun.shadow.camera.top = 10;
      sun.shadow.camera.bottom = -10;
      scene.add(sun);

      /* -------------------- Shadow Receiver (floor) ------------------ */
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 40),
        new THREE.MeshStandardMaterial({
          color: 0x0d1117,
          roughness: 0.95,
        }),
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -5.0;
      ground.receiveShadow = true;
      scene.add(ground);

      /* -------------------- Build 5D hypercube ----------------------- */
      const N = 5, SIZE = 1.0;
      const verts5 = [];
      for (let i = 0; i < (1 << N); i++) {
        const v = new Array(N);
        for (let d = 0; d < N; d++) {
          v[d] = ((i >> d) & 1) ? SIZE : -SIZE;
        }
        verts5.push(v);
      }
      const edges = [];
      for (let i = 0; i < (1 << N); i++) {
        for (let d = 0; d < N; d++) {
          const j = i ^ (1 << d);
          if (j > i) edges.push([i, j]);
        }
      }

      /* ------------- 5D rotation + perspective projection ------------ */
      const planes = [
        [0, 1],
        [0, 2],
        [0, 3],
        [0, 4],
        [1, 2],
        [1, 3],
        [1, 4],
        [2, 3],
        [2, 4],
        [3, 4],
      ];
      const angles = new Float32Array(planes.length).fill(0);
      const spinWeights = new Float32Array([
        1,
        .6,
        .4,
        .2,
        .8,
        .4,
        .2,
        .5,
        .25,
        .15,
      ]);

      const fw = 3.0; // W focal (4D→3D)
      const fv = 5.0; // V focal (5D→4D)

      function rotate5D(vec) {
        for (let p = 0; p < planes.length; p++) {
          const [i, j] = planes[p], t = angles[p];
          const c = Math.cos(t), s = Math.sin(t);
          const a = vec[i], b = vec[j];
          vec[i] = a * c - b * s;
          vec[j] = a * s + b * c;
        }
      }
      function project5Dto3D(v5) {
        const V = v5[4];
        const sv = fv / (fv - V);
        const x4 = v5[0] * sv,
          y4 = v5[1] * sv,
          z4 = v5[2] * sv,
          w4 = v5[3] * sv;
        const sw = fw / (fw - w4);
        return new THREE.Vector3(x4 * sw, y4 * sw, z4 * sw);
      }

      /* ---------- Edges as skinny cylinders + crisp line overlay ----- */
      const cylGeom = new THREE.CylinderGeometry(1, 1, 1, 10, 1, true);
      const cylMat = new THREE.MeshStandardMaterial({
        color: 0x93c5fd,
        roughness: 0.6,
        metalness: 0.25,
      });
      const tubes = new THREE.InstancedMesh(
        cylGeom,
        cylMat,
        edges.length,
      );
      tubes.castShadow = true;
      scene.add(tubes);

      const linePos = new Float32Array(edges.length * 2 * 3);
      const lineGeom = new THREE.BufferGeometry();
      lineGeom.setAttribute(
        "position",
        new THREE.BufferAttribute(linePos, 3),
      );
      const line = new THREE.LineSegments(
        lineGeom,
        new THREE.LineBasicMaterial({
          color: 0x93c5fd,
          opacity: 0.9,
          transparent: true,
        }),
      );
      scene.add(line);

      const sphGeom = new THREE.SphereGeometry(1, 16, 12);
      const sphMat = new THREE.MeshStandardMaterial({
        color: 0xe5e7eb,
        roughness: 0.85,
      });
      const balls = new THREE.InstancedMesh(
        sphGeom,
        sphMat,
        verts5.length,
      );
      balls.castShadow = true;
      scene.add(balls);

      const v3 = verts5.map((_) => new THREE.Vector3());
      const tmp5 = new Array(5).fill(0);
      const up = new THREE.Vector3(0, 1, 0);
      const M = new THREE.Matrix4();
      const Q = new THREE.Quaternion();
      const S = new THREE.Vector3();

      function updateGeometry() {
        for (let i = 0; i < verts5.length; i++) {
          for (let d = 0; d < 5; d++) tmp5[d] = verts5[i][d];
          rotate5D(tmp5);
          v3[i].copy(project5Dto3D(tmp5));

          S.set(0.06, 0.06, 0.06);
          Q.identity();
          M.compose(v3[i], Q, S);
          balls.setMatrixAt(i, M);
        }
        balls.instanceMatrix.needsUpdate = true;

        let k = 0;
        for (let e = 0; e < edges.length; e++) {
          const [a, b] = edges[e];
          const A = v3[a], B = v3[b];

          linePos[k++] = A.x;
          linePos[k++] = A.y;
          linePos[k++] = A.z;
          linePos[k++] = B.x;
          linePos[k++] = B.y;
          linePos[k++] = B.z;

          const mid = new THREE.Vector3().addVectors(A, B)
            .multiplyScalar(0.5);
          const dir = new THREE.Vector3().subVectors(B, A);
          const len = dir.length();
          if (len > 1e-6) {
            const quat = new THREE.Quaternion().setFromUnitVectors(
              up,
              dir.clone().normalize(),
            );
            S.set(0.03, len, 0.03);
            M.compose(mid, quat, S);
            tubes.setMatrixAt(e, M);
          }
        }
        lineGeom.attributes.position.needsUpdate = true;
        tubes.instanceMatrix.needsUpdate = true;
      }

      /* ------------------------ Animate ------------------------------ */
      let last = performance.now();
      function tick() {
        const now = performance.now();
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;

        const base = 0.7 * dt;
        for (let i = 0; i < angles.length; i++) {
          angles[i] += base * spinWeights[i];
        }

        updateGeometry();
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      updateGeometry();
      tick();

      /* ------------------------ Resize ------------------------------- */
      addEventListener("resize", () => {
        renderer.setSize(innerWidth, innerHeight);
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
